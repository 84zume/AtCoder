#!/usr/bin/env python3
# from typing import *
class DisjointSet:
    def __init__(self) -> None:
        self.parent = {}
        self.size = {}

    def makeSet(self, set):
        for e in set:
            self.parent[e] = e
            self.size[e] = 1

    def Find(self, x):
        if self.parent[x] == x:
            return x
        else:
            # 経路圧縮
            self.parent[x] = self.Find(self.parent[x])
            return self.parent[x]

    def Union(self, x, y):
        a = self.Find(x)
        b = self.Find(y)

        if a == b:
            return False

        # union by sizeで効率化
        if self.size[a] < self.size[b]:
            a, b = b, a

        self.parent[b] = a
        self.size[a] += self.size[b]
        return True

    def issame(self, x, y):
        return self.Find(x) == self.Find(y)

    def getsize(self, x):
        return self.size[self.Find(x)]


def printSets(set, ds):
    return [ds.Find(i) for i in set]


# def solve(N: int, M: int, A: List[int], B: List[int]) -> List[str]:
def solve(N, M, A, B):
    ans = []
    for broken in range(M):
        ds = DisjointSet()
        s = [i + 1 for i in range(N)]
        ds.makeSet(s)
        for i in range(broken, M):
            ds.Union(A[i], B[i])
        count_set = set()
        for i in s:
            count_set.add(ds.Find(i))
        ans.append(len(list(count_set)) - 1)
    return ans


# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    N, M = map(int, input().split())
    A = [None for _ in range(M)]
    B = [None for _ in range(M)]
    for i in range(M):
        A[i], B[i] = map(int, input().split())
    ans = solve(N, M, A, B)
    for i in range(M):
        print(ans[i])


if __name__ == "__main__":
    main()
